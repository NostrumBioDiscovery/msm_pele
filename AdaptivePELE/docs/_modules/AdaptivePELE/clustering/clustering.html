

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>AdaptivePELE.clustering.clustering &mdash; AdaptivePELE  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="AdaptivePELE  documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> AdaptivePELE
          

          
          </a>

          
            
            
              <div class="version">
                v1.5.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Examples.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Problems.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../AdaptivePELE.html">AdaptivePELE â€“ Package Description</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Changelog.html">Changelog</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">AdaptivePELE</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          









<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
        <li><a href="../../index.html">Module code</a> &raquo;</li>
      
    <li>AdaptivePELE.clustering.clustering</li>
    <li class="wy-breadcrumbs-aside">
      
          
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for AdaptivePELE.clustering.clustering</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="k">import</span> <span class="nb">range</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="k">import</span> <span class="n">reraise</span> <span class="k">as</span> <span class="n">raise_</span>
<span class="kn">from</span> <span class="nn">AdaptivePELE.constants</span> <span class="k">import</span> <span class="n">blockNames</span>
<span class="kn">from</span> <span class="nn">AdaptivePELE.utilities</span> <span class="k">import</span> <span class="n">utilities</span>
<span class="kn">from</span> <span class="nn">AdaptivePELE.atomset</span> <span class="k">import</span> <span class="n">SymmetryContactMapEvaluator</span> <span class="k">as</span> <span class="n">sym</span>
<span class="kn">from</span> <span class="nn">AdaptivePELE.atomset</span> <span class="k">import</span> <span class="n">RMSDCalculator</span>
<span class="kn">from</span> <span class="nn">AdaptivePELE.atomset</span> <span class="k">import</span> <span class="n">atomset</span>
<span class="kn">from</span> <span class="nn">AdaptivePELE.clustering</span> <span class="k">import</span> <span class="n">clusteringTypes</span>
<span class="kn">from</span> <span class="nn">AdaptivePELE.clustering</span> <span class="k">import</span> <span class="n">thresholdcalculator</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">stats</span>
<span class="kn">import</span> <span class="nn">heapq</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
    <span class="n">NETWORK</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">NETWORK</span> <span class="o">=</span> <span class="kc">False</span>


<div class="viewcode-block" id="Clusters"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Clusters">[docs]</a><span class="k">class</span> <span class="nc">Clusters</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Defining pickling interface to avoid problems when working with old</span>
        <span class="c1"># simulations if the properties of the clustering-related classes have</span>
        <span class="c1"># changed</span>
        <span class="n">state</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;clusters&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="c1"># Restore instance attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;clusters&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">)</span>

<div class="viewcode-block" id="Clusters.addCluster"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Clusters.addCluster">[docs]</a>    <span class="k">def</span> <span class="nf">addCluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Add a new cluster</span>

<span class="sd">            :param cluster:  Cluster object to insert</span>
<span class="sd">            :type cluster: :py:class:`.Cluster`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span></div>

<div class="viewcode-block" id="Clusters.insertCluster"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Clusters.insertCluster">[docs]</a>    <span class="k">def</span> <span class="nf">insertCluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">cluster</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Insert a cluster in a specified index</span>

<span class="sd">            :param index: Positions at which insert the cluster</span>
<span class="sd">            :type index: int</span>
<span class="sd">            :param cluster:  Cluster object to insert</span>
<span class="sd">            :type cluster: :py:class:`.Cluster`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">cluster</span><span class="p">)</span></div>

<div class="viewcode-block" id="Clusters.getNumberClusters"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Clusters.getNumberClusters">[docs]</a>    <span class="k">def</span> <span class="nf">getNumberClusters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Get the number of clusters contained</span>

<span class="sd">            :returns: int -- Number of clusters contained</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">)</span></div>

<div class="viewcode-block" id="Clusters.getCluster"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Clusters.getCluster">[docs]</a>    <span class="k">def</span> <span class="nf">getCluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clusterNum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Get the cluster at position clusterNum</span>

<span class="sd">            :param clusterNum: Index of the cluster to retrieve</span>
<span class="sd">            :type clusterNum: int</span>
<span class="sd">            :returns: :py:class:`.Cluster` -- Cluster at position clusterNum</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">clusterNum</span><span class="p">]</span></div>

<div class="viewcode-block" id="Clusters.printClusters"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Clusters.printClusters">[docs]</a>    <span class="k">def</span> <span class="nf">printClusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Print clusters information</span>

<span class="sd">            :param verbose: Flag to control the verbosity of the code (default is False)</span>
<span class="sd">            :type verbose: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--------------&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CLUSTER #</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--------------&quot;</span><span class="p">)</span>
            <span class="n">cluster</span><span class="o">.</span><span class="n">printCluster</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">clusters</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">cluster</span></div>


<div class="viewcode-block" id="ConformationNetwork"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.ConformationNetwork">[docs]</a><span class="k">class</span> <span class="nc">ConformationNetwork</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Object that contains the conformation network, a network with clusters as</span>
<span class="sd">        nodes and edges representing trantions between clusters. The network is</span>
<span class="sd">        stored using the networkx package[1]</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Networkx python package https://networkx.github.io</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">NETWORK</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Defining pickling interface to avoid problems when working with old</span>
        <span class="c1"># simulations if the properties of the clustering-related classes have</span>
        <span class="c1"># changed</span>
        <span class="n">state</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;network&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="c1"># Restore instance attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;network&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">NETWORK</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">__version__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="s1">&#39;adj&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">__dict__</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;node&#39;</span><span class="p">,</span> <span class="s1">&#39;adj&#39;</span><span class="p">,</span> <span class="s1">&#39;graph&#39;</span><span class="p">,</span> <span class="s1">&#39;pred&#39;</span><span class="p">,</span> <span class="s1">&#39;succ&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s2">&quot;_&quot;</span><span class="o">+</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

<div class="viewcode-block" id="ConformationNetwork.add_node"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.ConformationNetwork.add_node">[docs]</a>    <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Add a node to the network (wrapper for networkx method)</span>

<span class="sd">            :param node: Name of the node</span>
<span class="sd">            :type node: int</span>
<span class="sd">            :param kwargs: Set or change attributes using key=value.</span>
<span class="sd">            :type kwargs: keyword arguments, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">NETWORK</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">attr_dict</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="ConformationNetwork.add_edge"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.ConformationNetwork.add_edge">[docs]</a>    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Add an edge to the network (wrapper for networkx method)</span>

<span class="sd">            :param source: Name of the source node</span>
<span class="sd">            :type source: int</span>
<span class="sd">            :param target: Name of the target node</span>
<span class="sd">            :type target: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">NETWORK</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">[</span><span class="n">source</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="s1">&#39;transition&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">transition</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="ConformationNetwork.writeConformationNetwork"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.ConformationNetwork.writeConformationNetwork">[docs]</a>    <span class="k">def</span> <span class="nf">writeConformationNetwork</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Write the conformational network to file to visualize it</span>

<span class="sd">            :param path: Path where to write the network</span>
<span class="sd">            :type path: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">NETWORK</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Package networkx not found! Could not write network</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">write_edgelist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span></div>

<div class="viewcode-block" id="ConformationNetwork.writeFDT"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.ConformationNetwork.writeFDT">[docs]</a>    <span class="k">def</span> <span class="nf">writeFDT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Write the first discovery tree to file in edgelist format to</span>
<span class="sd">            visualize it</span>

<span class="sd">            :param path: Path where to write the network</span>
<span class="sd">            :type path: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">NETWORK</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Package networkx not found! Could not write network</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fw</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;parent&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;root&#39;</span><span class="p">:</span>
                    <span class="n">fw</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="se">\t</span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;parent&#39;</span><span class="p">],</span> <span class="n">node</span><span class="p">))</span></div>

<div class="viewcode-block" id="ConformationNetwork.createPathwayToCluster"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.ConformationNetwork.createPathwayToCluster">[docs]</a>    <span class="k">def</span> <span class="nf">createPathwayToCluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clusterLeave</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Retrace the FDT from a specific cluster to the root where it was</span>
<span class="sd">            discovered</span>

<span class="sd">            :param clusterLeave: End point of the pathway to reconstruct</span>
<span class="sd">            :type clusterLeave: int</span>
<span class="sd">            :returns: list -- List of snapshots conforming a pathway</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pathway</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nodeLabel</span> <span class="o">=</span> <span class="n">clusterLeave</span>
        <span class="k">while</span> <span class="n">nodeLabel</span> <span class="o">!=</span> <span class="s2">&quot;root&quot;</span><span class="p">:</span>
            <span class="n">pathway</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nodeLabel</span><span class="p">)</span>
            <span class="n">nodeLabel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">nodeLabel</span><span class="p">][</span><span class="s1">&#39;parent&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">pathway</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="AltStructures"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.AltStructures">[docs]</a><span class="k">class</span> <span class="nc">AltStructures</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper class, each cluster will have an instance of AltStructures that</span>
<span class="sd">        will maintain a priority queue (pq) of alternative structures to spawn</span>
<span class="sd">        from encoded as tuples (priority, PDB).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">altStructPQ</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limitSize</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Defining pickling interface to avoid problems when working with old</span>
        <span class="c1"># simulations if the properties of the clustering-related classes have</span>
        <span class="c1"># changed</span>
        <span class="n">state</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;altStructPQ&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">altStructPQ</span><span class="p">,</span> <span class="s2">&quot;limitSize&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">limitSize</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="c1"># Restore instance attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limitSize</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;limitSize&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">altStructPQ</span> <span class="o">=</span> <span class="p">[(</span><span class="n">el</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span> <span class="n">el</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;altStructPQ&#39;</span><span class="p">])]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">altStructPQ</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="AltStructures.altSpawnSelection"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.AltStructures.altSpawnSelection">[docs]</a>    <span class="k">def</span> <span class="nf">altSpawnSelection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">centerPair</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Select an alternative PDB from the cluster center to spawn from</span>

<span class="sd">            :param centerPair: Tuple with the population of the representative structure</span>
<span class="sd">                and the PDB of said structure</span>
<span class="sd">            :type centerPair: int, :py:class:`.PDB`</span>
<span class="sd">            :returns: :py:class:`.PDB`, tuple -- PDB of the strucutre selected to spawn and tuple</span>
<span class="sd">                consisting of (epoch, trajectory, snapshot)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">subpopulations</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">altStructPQ</span><span class="p">]</span>
        <span class="n">totalSubpopulation</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">subpopulations</span><span class="p">)</span>
        <span class="c1"># Create a list of the population distributed between the cluster</span>
        <span class="c1"># center and the alternative structures</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">centerPair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">totalSubpopulation</span><span class="p">]</span><span class="o">+</span><span class="n">subpopulations</span><span class="p">)</span>
        <span class="n">weights</span> <span class="o">/=</span> <span class="n">weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c1"># This function only works on numpy &gt;= 1.7, on life we have 1.6</span>
        <span class="c1"># ind = np.random.choice(range(len(self.altStructPQ)), p=weights)</span>
        <span class="c1"># Add one to account for the cluster representative</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">rv_discrete</span><span class="p">(</span><span class="n">values</span><span class="o">=</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sizePQ</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">weights</span><span class="p">))</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># The first value of the distribution is always the cluster center</span>
        <span class="k">if</span> <span class="n">ind</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;cluster center&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">centerPair</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># pick an alternative structure from the priority queue</span>
            <span class="c1"># The first element corresponds to the cluster center</span>
            <span class="n">ind</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;alternative structure&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">altStructPQ</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">pdb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">altStructPQ</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">trajPosition</span></div>

<div class="viewcode-block" id="AltStructures.cleanPQ"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.AltStructures.cleanPQ">[docs]</a>    <span class="k">def</span> <span class="nf">cleanPQ</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Ensure that the alternative structures priority queue has no more</span>
<span class="sd">            elements than the limit in order to ensure efficiency</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">altStructPQ</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">limitSize</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">limit</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">altStructPQ</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">altStructPQ</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">limitSize</span><span class="o">-</span><span class="n">limit</span><span class="p">:]</span></div>

<div class="viewcode-block" id="AltStructures.addStructure"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.AltStructures.addStructure">[docs]</a>    <span class="k">def</span> <span class="nf">addStructure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">PDB</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">resname</span><span class="p">,</span> <span class="n">resnum</span><span class="p">,</span> <span class="n">resChain</span><span class="p">,</span> <span class="n">contactThreshold</span><span class="p">,</span> <span class="n">similarityEvaluator</span><span class="p">,</span> <span class="n">trajPosition</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Perform a subclustering, with sub-clusters of size threshold/2</span>

<span class="sd">            :param PDB: Structure to cluster</span>
<span class="sd">            :type PDB: :py:class:`.PDB`</span>
<span class="sd">            :param threshold: Size of the cluster</span>
<span class="sd">            :type threshold: float</span>
<span class="sd">            :param resname: String containing the three letter name of the ligand in the pdb</span>
<span class="sd">            :type resname: str</span>
<span class="sd">            :param resnum: Integer containing the residue number of the ligand in the pdb</span>
<span class="sd">            :type resnum: int</span>
<span class="sd">            :param resChain: String containing the chain name of the ligand in the pdb</span>
<span class="sd">            :type resChain: str</span>
<span class="sd">            :param contactThreshold: Distance at which to atoms are considered in contact</span>
<span class="sd">            :type contactThreshold: float</span>
<span class="sd">            :param similarityEvaluator: Object that determinates the similarity between two structures</span>
<span class="sd">            :type similarityEvaluator: :py:class:`.SimilarityEvaluator`</span>
<span class="sd">            :param trajPosition: Tuple of (epoch, trajectory, snapshot) that permit</span>
<span class="sd">                identifying the structure added</span>
<span class="sd">            :type trajPosition: int, int, int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">subCluster</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">altStructPQ</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">similarityEvaluator</span><span class="o">.</span><span class="n">isElement</span><span class="p">(</span><span class="n">PDB</span><span class="p">,</span> <span class="n">subCluster</span><span class="p">,</span> <span class="n">resname</span><span class="p">,</span> <span class="n">resnum</span><span class="p">,</span> <span class="n">resChain</span><span class="p">,</span> <span class="n">contactThreshold</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">subCluster</span><span class="o">.</span><span class="n">threshold</span><span class="o">/</span><span class="mf">2.0</span><span class="p">:</span>
                <span class="n">subCluster</span><span class="o">.</span><span class="n">addElement</span><span class="p">([])</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">altStructPQ</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">altStructPQ</span><span class="p">,</span> <span class="p">(</span><span class="n">subCluster</span><span class="o">.</span><span class="n">elements</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">updateIndex</span><span class="p">(),</span> <span class="n">subCluster</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">altStructPQ</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">limitSize</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cleanPQ</span><span class="p">()</span>
                <span class="k">return</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">newCluster</span> <span class="o">=</span> <span class="n">Cluster</span><span class="p">(</span><span class="n">PDB</span><span class="p">,</span> <span class="n">thresholdRadius</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">contactThreshold</span><span class="o">=</span><span class="n">contactThreshold</span><span class="p">,</span> <span class="n">contactMap</span><span class="o">=</span><span class="n">similarityEvaluator</span><span class="o">.</span><span class="n">contactMap</span><span class="p">,</span> <span class="n">trajPosition</span><span class="o">=</span><span class="n">trajPosition</span><span class="p">)</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">altStructPQ</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">updateIndex</span><span class="p">(),</span> <span class="n">newCluster</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">altStructPQ</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">limitSize</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cleanPQ</span><span class="p">()</span></div>

<div class="viewcode-block" id="AltStructures.updateIndex"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.AltStructures.updateIndex">[docs]</a>    <span class="k">def</span> <span class="nf">updateIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Update the index which represents chronological order of entries in</span>
<span class="sd">            the priority queue</span>

<span class="sd">            :returns: int -- Index of the following element</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span></div>

<div class="viewcode-block" id="AltStructures.sizePQ"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.AltStructures.sizePQ">[docs]</a>    <span class="k">def</span> <span class="nf">sizePQ</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Get the number of sub-clusters stored in the priority queue</span>

<span class="sd">            :returns: int -- Number of sub-clusters stored in the priority queue</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">altStructPQ</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Cluster"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Cluster">[docs]</a><span class="k">class</span> <span class="nc">Cluster</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A cluster contains a representative structure(pdb), the number of</span>
<span class="sd">        elements, its density, threshold, number of contacts,</span>
<span class="sd">        a contactMap(sometimes) and a metric</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdb</span><span class="p">,</span> <span class="n">thresholdRadius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">contactMap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">contacts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metrics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metricCol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">contactThreshold</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">altSelection</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">trajPosition</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            :param pdb: Pdb of the representative structure</span>
<span class="sd">            :type pdb: :py:class:`.PDB`</span>
<span class="sd">            :param thresholdRadius: Threshold of the cluster</span>
<span class="sd">            :type thresholdRadius: float</span>
<span class="sd">            :param contactMap:  The contact map of the ligand and the protein</span>
<span class="sd">            :type contactMap: numpy.Array</span>
<span class="sd">            :param contacts: Ratio of the number of alpha carbons in contact with the ligand</span>
<span class="sd">            :type contacts: float</span>
<span class="sd">            :param metrics: Array of the metrics corresponding to the cluster</span>
<span class="sd">            :type metrics: numpy.Array</span>
<span class="sd">            :param metricCol: Column of the prefered metric</span>
<span class="sd">            :type metricCol: int</span>
<span class="sd">            :param density: Density of the cluster</span>
<span class="sd">            :type density: float</span>
<span class="sd">            :param contactThreshold: Distance between two atoms to be considered in contact (default 8)</span>
<span class="sd">            :type contactThreshold: float</span>
<span class="sd">            :param altSelection: Flag that controls wether to use the alternative structures (default 8)</span>
<span class="sd">            :type altSelection: bool</span>
<span class="sd">            :param trajPosition: Tuple of (epoch, trajectory, snapshot) that permit</span>
<span class="sd">                identifying the structure added</span>
<span class="sd">            :type trajPosition: int, int, int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdb</span> <span class="o">=</span> <span class="n">pdb</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">altStructure</span> <span class="o">=</span> <span class="n">AltStructures</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">thresholdRadius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">density</span> <span class="o">=</span> <span class="n">density</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contacts</span> <span class="o">=</span> <span class="n">contacts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contactMap</span> <span class="o">=</span> <span class="n">contactMap</span>
        <span class="k">if</span> <span class="n">metrics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metrics</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metrics</span> <span class="o">=</span> <span class="n">metrics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">originalMetrics</span> <span class="o">=</span> <span class="n">metrics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metricCol</span> <span class="o">=</span> <span class="n">metricCol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contactThreshold</span> <span class="o">=</span> <span class="n">contactThreshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">altSelection</span> <span class="o">=</span> <span class="n">altSelection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trajPosition</span> <span class="o">=</span> <span class="n">trajPosition</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">threshold2</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">threshold2</span> <span class="o">=</span> <span class="n">thresholdRadius</span><span class="o">*</span><span class="n">thresholdRadius</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Defining pickling interface to avoid problems when working with old</span>
        <span class="c1"># simulations if the properties of the clustering-related classes have</span>
        <span class="c1"># changed</span>
        <span class="n">state</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;pdb&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdb</span><span class="p">,</span> <span class="s2">&quot;altStructure&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">altStructure</span><span class="p">,</span>
                 <span class="s2">&quot;elements&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">,</span> <span class="s2">&quot;threshold&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">,</span>
                 <span class="s2">&quot;densitiy&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">density</span><span class="p">,</span> <span class="s2">&quot;contacts&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">contacts</span><span class="p">,</span>
                 <span class="s2">&quot;contactMap&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">contactMap</span><span class="p">,</span> <span class="s2">&quot;metrics&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">metrics</span><span class="p">,</span>
                 <span class="s2">&quot;metricCol&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">metricCol</span><span class="p">,</span> <span class="s2">&quot;threshold2&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold2</span><span class="p">,</span>
                 <span class="s2">&quot;contactThreshold&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">contactThreshold</span><span class="p">,</span>
                 <span class="s2">&quot;altSelection&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">altSelection</span><span class="p">,</span>
                 <span class="s2">&quot;originalMetrics&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">originalMetrics</span><span class="p">,</span>
                 <span class="s2">&quot;trajPosition&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajPosition</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="c1"># Restore instance attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdb</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;pdb&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">altStructure</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;altStructure&#39;</span><span class="p">,</span> <span class="n">AltStructures</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;elements&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;threshold&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">density</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;density&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contacts</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;contacts&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contactMap</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;contactMap&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metrics</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;metrics&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">originalMetrics</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;originalMetrics&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metricCol</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;metricCol&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold2</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;threshold2&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contactThreshold</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;contactThreshold&#39;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">altSelection</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;altSelection&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trajPosition</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;trajPosition&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span>

<div class="viewcode-block" id="Cluster.getMetric"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Cluster.getMetric">[docs]</a>    <span class="k">def</span> <span class="nf">getMetric</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Get the value of the prefered metric if present, otherwise return None</span>

<span class="sd">            :returns: float -- Value of the prefered metric</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metrics</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">metricCol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metrics</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">metricCol</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Cluster.getMetricFromColumn"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Cluster.getMetricFromColumn">[docs]</a>    <span class="k">def</span> <span class="nf">getMetricFromColumn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numcol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Get the value of the metric in column numcol if present, otherwise return None</span>

<span class="sd">            :param numcol: Column of the desired metric</span>
<span class="sd">            :type numcol: int</span>
<span class="sd">            :returns: float -- Value of the prefered metric</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metrics</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metrics</span><span class="p">[</span><span class="n">numcol</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Cluster.addElement"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Cluster.addElement">[docs]</a>    <span class="k">def</span> <span class="nf">addElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metrics</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Add a new element to the cluster</span>

<span class="sd">            :param metrics: Array of metrics of the new structure</span>
<span class="sd">            :type metrics: numpy.Array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metrics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Special case where cluster in created during clustering of</span>
            <span class="c1"># initial structures</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metrics</span> <span class="o">=</span> <span class="n">metrics</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">originalMetrics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">originalMetrics</span> <span class="o">=</span> <span class="n">metrics</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">metrics</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metrics</span><span class="p">):</span>
            <span class="c1"># Set all metrics to the minimum value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metrics</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metrics</span><span class="p">,</span> <span class="n">metrics</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cluster.printCluster"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Cluster.printCluster">[docs]</a>    <span class="k">def</span> <span class="nf">printCluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Print cluster information</span>

<span class="sd">            :param verbose: Flag to control the verbosity of the code (default is False)</span>
<span class="sd">            :type verbose: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdb</span><span class="o">.</span><span class="n">printAtoms</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Elements: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Metrics: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metrics</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Radius threshold: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of contacts: </span><span class="si">%.2f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">contacts</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Cluster: elements=</span><span class="si">%d</span><span class="s2">, threshold=</span><span class="si">%.3f</span><span class="s2">, contacts=</span><span class="si">%.3f</span><span class="s2">, density=</span><span class="si">%.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contacts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">density</span> <span class="ow">or</span> <span class="mf">0.000</span><span class="p">)</span>

<div class="viewcode-block" id="Cluster.writePDB"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Cluster.writePDB">[docs]</a>    <span class="k">def</span> <span class="nf">writePDB</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Write the pdb of the representative structure to file</span>

<span class="sd">            :param path: Filename of the file to write</span>
<span class="sd">            :type path: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">topology</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">topology</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdb</span><span class="o">.</span><span class="n">writePDB</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">))</span></div>

<div class="viewcode-block" id="Cluster.getContacts"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Cluster.getContacts">[docs]</a>    <span class="k">def</span> <span class="nf">getContacts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Get the contacts ratio of the cluster</span>

<span class="sd">            :returns: float -- contact ratio of the cluster</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">contacts</span></div>

<div class="viewcode-block" id="Cluster.writeSpawningStructure"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Cluster.writeSpawningStructure">[docs]</a>    <span class="k">def</span> <span class="nf">writeSpawningStructure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Write the pdb of the chosen structure to spawn</span>

<span class="sd">            :param path: Filename of the file to write</span>
<span class="sd">            :type path: str</span>

<span class="sd">            :returns int, int, int: Tuple of (epoch, trajectory, snapshot) that permit</span>
<span class="sd">                identifying the structure added</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">altSelection</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">altStructure</span><span class="o">.</span><span class="n">sizePQ</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;cluster center&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pdb</span><span class="o">.</span><span class="n">writePDB</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajPosition</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spawnStruct</span><span class="p">,</span> <span class="n">trajPosition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">altStructure</span><span class="o">.</span><span class="n">altSpawnSelection</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdb</span><span class="p">))</span>
            <span class="n">spawnStruct</span><span class="o">.</span><span class="n">writePDB</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">trajPosition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">trajPosition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajPosition</span>
            <span class="k">return</span> <span class="n">trajPosition</span></div>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdb</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">pdb</span>\
             <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">elements</span>\
             <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">threshold</span>\
             <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">contacts</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">contacts</span>\
             <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metrics</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">metrics</span><span class="p">)</span></div>


<div class="viewcode-block" id="ClusteringEvaluator"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.ClusteringEvaluator">[docs]</a><span class="k">class</span> <span class="nc">ClusteringEvaluator</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contactMap</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contacts</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="ClusteringEvaluator.cleanContactMap"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.ClusteringEvaluator.cleanContactMap">[docs]</a>    <span class="k">def</span> <span class="nf">cleanContactMap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Clean the attributes to prepare for next iteration</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contactMap</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contacts</span> <span class="o">=</span> <span class="kc">None</span></div></div>


<div class="viewcode-block" id="ContactsClusteringEvaluator"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.ContactsClusteringEvaluator">[docs]</a><span class="k">class</span> <span class="nc">ContactsClusteringEvaluator</span><span class="p">(</span><span class="n">ClusteringEvaluator</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">RMSDCalculator_object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Helper object to carry out the RMSD clustering</span>

<span class="sd">            :param RMSDCalculator: object that calculates the RMSD between two</span>
<span class="sd">                conformations</span>
<span class="sd">            :type RMSDCalculator: :py:class:`.RMSDCalculator`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ClusteringEvaluator</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">RMSDCalculator</span> <span class="o">=</span> <span class="n">RMSDCalculator_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contacts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Only here for compatibility purpose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contactMap</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Defining pickling interface to avoid problems when working with old</span>
        <span class="c1"># simulations if the properties of the clustering-related classes have</span>
        <span class="c1"># changed</span>
        <span class="n">state</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;RMSDCalculator&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">RMSDCalculator</span><span class="p">,</span>
                 <span class="s2">&quot;contacts&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">contacts</span><span class="p">,</span> <span class="s2">&quot;contactMap&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">contactMap</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="c1"># Restore instance attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">RMSDCalculator</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;RMSDCalculator&#39;</span><span class="p">,</span> <span class="n">RMSDCalculator</span><span class="o">.</span><span class="n">RMSDCalculator</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contacts</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;contacts&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contactMap</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;contactMap&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="ContactsClusteringEvaluator.isElement"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.ContactsClusteringEvaluator.isElement">[docs]</a>    <span class="k">def</span> <span class="nf">isElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdb</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">resname</span><span class="p">,</span> <span class="n">resnum</span><span class="p">,</span> <span class="n">resChain</span><span class="p">,</span> <span class="n">contactThresholdDistance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Evaluate wether a conformation is a member of a cluster</span>

<span class="sd">            :param pdb: Structure to compare</span>
<span class="sd">            :type pdb: :py:class:`.PDB`</span>
<span class="sd">            :param cluster: Cluster to compare</span>
<span class="sd">            :type cluster: :py:class:`.Cluster`</span>
<span class="sd">            :param resname: String containing the three letter name of the ligand in the pdb</span>
<span class="sd">            :type resname: str</span>
<span class="sd">            :param resnum: Integer containing the residue number of the ligand in the pdb</span>
<span class="sd">            :type resnum: int</span>
<span class="sd">            :param resChain: String containing the chain name of the ligand in the pdb</span>
<span class="sd">            :type resChain: str</span>
<span class="sd">            :param contactThreshold: Distance between two atoms to be considered in contact (default 8)</span>
<span class="sd">            :type contactThreshold: float</span>
<span class="sd">            :returns: bool, float -- Whether the structure belong to the cluster and the distance between them</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RMSDCalculator</span><span class="o">.</span><span class="n">computeRMSD</span><span class="p">(</span><span class="n">cluster</span><span class="o">.</span><span class="n">pdb</span><span class="p">,</span> <span class="n">pdb</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">cluster</span><span class="o">.</span><span class="n">threshold</span><span class="p">,</span> <span class="n">dist</span></div>

<div class="viewcode-block" id="ContactsClusteringEvaluator.checkAttributes"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.ContactsClusteringEvaluator.checkAttributes">[docs]</a>    <span class="k">def</span> <span class="nf">checkAttributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdb</span><span class="p">,</span> <span class="n">resname</span><span class="p">,</span> <span class="n">resnum</span><span class="p">,</span> <span class="n">resChain</span><span class="p">,</span> <span class="n">contactThresholdDistance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Check wether all attributes are set for this iteration</span>

<span class="sd">            :param pdb: Structure to compare</span>
<span class="sd">            :type pdb: :py:class:`.PDB`</span>
<span class="sd">            :param resname: String containing the three letter name of the ligand in the pdb</span>
<span class="sd">            :type resname: str</span>
<span class="sd">            :param resnum: Integer containing the residue number of the ligand in the pdb</span>
<span class="sd">            :type resnum: int</span>
<span class="sd">            :param resChain: String containing the chain name of the ligand in the pdb</span>
<span class="sd">            :type resChain: str</span>
<span class="sd">            :param contactThreshold: Distance between two atoms to be considered in contact (default 8)</span>
<span class="sd">            :type contactThreshold: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">contacts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">contacts</span> <span class="o">=</span> <span class="n">pdb</span><span class="o">.</span><span class="n">countContacts</span><span class="p">(</span><span class="n">resname</span><span class="p">,</span> <span class="n">contactThresholdDistance</span><span class="p">,</span> <span class="n">resnum</span><span class="p">,</span> <span class="n">resChain</span><span class="p">)</span></div>

<div class="viewcode-block" id="ContactsClusteringEvaluator.getInnerLimit"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.ContactsClusteringEvaluator.getInnerLimit">[docs]</a>    <span class="k">def</span> <span class="nf">getInnerLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Return the threshold of the cluster</span>

<span class="sd">            :param cluster: Cluster to compare</span>
<span class="sd">            :type cluster: :py:class:`.Cluster`</span>
<span class="sd">            :returns: float -- Threshold of the cluster</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cluster</span><span class="o">.</span><span class="n">threshold2</span></div></div>


<div class="viewcode-block" id="CMClusteringEvaluator"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.CMClusteringEvaluator">[docs]</a><span class="k">class</span> <span class="nc">CMClusteringEvaluator</span><span class="p">(</span><span class="n">ClusteringEvaluator</span><span class="p">):</span>
    <span class="n">limitSlope</span> <span class="o">=</span> <span class="p">{</span><span class="mi">8</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">10</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
    <span class="n">limitMax</span> <span class="o">=</span> <span class="p">{</span><span class="mi">8</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mi">10</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">similarityEvaluator</span><span class="p">,</span> <span class="n">symmetryEvaluator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Helper object to carry out the RMSD clustering</span>

<span class="sd">            :param similarityEvaluator: object that calculates the similarity</span>
<span class="sd">                between two contact maps</span>
<span class="sd">            :type similarityEvaluator: :py:class:`.CMSimilarityEvaluator`</span>
<span class="sd">            :param symmetryEvaluator: object to introduce the symmetry  in the</span>
<span class="sd">                contacts maps</span>
<span class="sd">            :type symmetryEvaluator: :py:class:`.SymmetryContactMapEvaluator`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ClusteringEvaluator</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">similarityEvaluator</span> <span class="o">=</span> <span class="n">similarityEvaluator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symmetryEvaluator</span> <span class="o">=</span> <span class="n">symmetryEvaluator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contacts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contactMap</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Defining pickling interface to avoid problems when working with old</span>
        <span class="c1"># simulations if the properties of the clustering-related classes have</span>
        <span class="c1"># changed</span>
        <span class="n">state</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;similarityEvaluator&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">similarityEvaluator</span><span class="p">,</span>
                 <span class="s2">&quot;symmetryEvaluator&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetryEvaluator</span><span class="p">,</span>
                 <span class="s2">&quot;contacts&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">contacts</span><span class="p">,</span> <span class="s2">&quot;contactMap&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">contactMap</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="c1"># Restore instance attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">similarityEvaluator</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;similarityEvaluator&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symmetryEvaluator</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;symmetryEvaluator&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contacts</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;contacts&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contactMap</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;contactMap&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="CMClusteringEvaluator.isElement"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.CMClusteringEvaluator.isElement">[docs]</a>    <span class="k">def</span> <span class="nf">isElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdb</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">resname</span><span class="p">,</span> <span class="n">resnum</span><span class="p">,</span> <span class="n">resChain</span><span class="p">,</span> <span class="n">contactThresholdDistance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Evaluate wether a conformation is a member of a cluster</span>

<span class="sd">            :param pdb: Structure to compare</span>
<span class="sd">            :type pdb: :py:class:`.PDB`</span>
<span class="sd">            :param cluster: Cluster to compare</span>
<span class="sd">            :type cluster: :py:class:`.Cluster`</span>
<span class="sd">            :param resname: String containing the three letter name of the ligand in the pdb</span>
<span class="sd">            :type resname: str</span>
<span class="sd">            :param resnum: Integer containing the residue number of the ligand in the pdb</span>
<span class="sd">            :type resnum: int</span>
<span class="sd">            :param resChain: String containing the chain name of the ligand in the pdb</span>
<span class="sd">            :type resChain: str</span>
<span class="sd">            :param contactThreshold: Distance between two atoms to be considered in contact (default 8)</span>
<span class="sd">            :type contactThreshold: float</span>
<span class="sd">            :returns: bool, float -- Whether the structure belong to the cluster and the distance between them</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">contactMap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">contactMap</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contacts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetryEvaluator</span><span class="o">.</span><span class="n">createContactMap</span><span class="p">(</span><span class="n">pdb</span><span class="p">,</span> <span class="n">resname</span><span class="p">,</span> <span class="n">contactThresholdDistance</span><span class="p">,</span> <span class="n">resnum</span><span class="p">,</span> <span class="n">resChain</span><span class="p">)</span>
            <span class="c1"># self.contactMap, foo = self.symmetryEvaluator.createContactMap(pdb, resname, contactThresholdDistance)</span>
            <span class="c1"># self.contacts = pdb.countContacts(resname, 8)  # contactThresholdDistance)</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">similarityEvaluator</span><span class="o">.</span><span class="n">isSimilarCluster</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contactMap</span><span class="p">,</span> <span class="n">cluster</span><span class="o">.</span><span class="n">contactMap</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetryEvaluator</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">cluster</span><span class="o">.</span><span class="n">threshold</span><span class="p">,</span> <span class="n">distance</span></div>

<div class="viewcode-block" id="CMClusteringEvaluator.checkAttributes"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.CMClusteringEvaluator.checkAttributes">[docs]</a>    <span class="k">def</span> <span class="nf">checkAttributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdb</span><span class="p">,</span> <span class="n">resname</span><span class="p">,</span> <span class="n">resnum</span><span class="p">,</span> <span class="n">resChain</span><span class="p">,</span> <span class="n">contactThresholdDistance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Check wether all attributes are set for this iteration</span>

<span class="sd">            :param pdb: Structure to compare</span>
<span class="sd">            :type pdb: :py:class:`.PDB`</span>
<span class="sd">            :param resname: String containing the three letter name of the ligand in the pdb</span>
<span class="sd">            :type resname: str</span>
<span class="sd">            :param resnum: Integer containing the residue number of the ligand in the pdb</span>
<span class="sd">            :type resnum: int</span>
<span class="sd">            :param resChain: String containing the chain name of the ligand in the pdb</span>
<span class="sd">            :type resChain: str</span>
<span class="sd">            :param contactThreshold: Distance between two atoms to be considered in contact (default 8)</span>
<span class="sd">            :type contactThreshold: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">contactMap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">contactMap</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contacts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetryEvaluator</span><span class="o">.</span><span class="n">createContactMap</span><span class="p">(</span><span class="n">pdb</span><span class="p">,</span> <span class="n">resname</span><span class="p">,</span> <span class="n">contactThresholdDistance</span><span class="p">,</span> <span class="n">resnum</span><span class="p">,</span> <span class="n">resChain</span><span class="p">)</span></div>
            <span class="c1"># self.contactMap, foo = self.symmetryEvaluator.createContactMap(pdb, resname, contactThresholdDistance)</span>
            <span class="c1"># self.contacts = pdb.countContacts(resname, 8)  # contactThresholdDistance)</span>

<div class="viewcode-block" id="CMClusteringEvaluator.getInnerLimit"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.CMClusteringEvaluator.getInnerLimit">[docs]</a>    <span class="k">def</span> <span class="nf">getInnerLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Return the threshold of the cluster</span>

<span class="sd">            :param cluster: Cluster to compare</span>
<span class="sd">            :type cluster: :py:class:`.Cluster`</span>
<span class="sd">            :returns: float -- Threshold of the cluster</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if cluster.contacts &gt; self.limitMax[cluster.contactThreshold]:</span>
        <span class="c1">#     return 4.0</span>
        <span class="c1"># else:</span>
        <span class="c1">#     return 16-self.limitSlope[cluster.contactThreshold]*cluster.contacts</span>

        <span class="c1"># if cluster.contacts &gt; 2.0:</span>
        <span class="c1">#     return 4.0</span>
        <span class="c1"># elif cluster.contacts &lt;= 0.5:</span>
        <span class="c1">#     return 25.0</span>
        <span class="c1"># else:</span>
        <span class="c1">#     return 25-14*(cluster.contacts-0.5)</span>

        <span class="k">if</span> <span class="n">cluster</span><span class="o">.</span><span class="n">contacts</span> <span class="o">&gt;</span> <span class="mf">2.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">4.0</span>
        <span class="k">elif</span> <span class="n">cluster</span><span class="o">.</span><span class="n">contacts</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">25.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">16</span><span class="o">-</span><span class="mi">8</span><span class="o">*</span><span class="p">(</span><span class="n">cluster</span><span class="o">.</span><span class="n">contacts</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span></div></div>

        <span class="c1"># if cluster.contacts &gt; 1.0:</span>
        <span class="c1">#     return 4.0</span>
        <span class="c1"># elif cluster.contacts &gt; 0.75:</span>
        <span class="c1">#     return 9.0</span>
        <span class="c1"># elif cluster.contacts &gt; 0.5:</span>
        <span class="c1">#     return 16.0</span>
        <span class="c1"># else:</span>
        <span class="c1">#      return 25</span>


<div class="viewcode-block" id="Clustering"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Clustering">[docs]</a><span class="k">class</span> <span class="nc">Clustering</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resname</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">resnum</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">resChain</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">reportBaseFilename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">columnOfReportFile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">contactThresholdDistance</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
                 <span class="n">altSelection</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Base class for clustering methods, it defines a cluster method that</span>
<span class="sd">            contacts and accumulative inherit and use</span>

<span class="sd">            :param resname: String containing the three letter name of the ligand in the pdb</span>
<span class="sd">            :type resname: str</span>
<span class="sd">            :param resnum: Integer containing the residue number of the ligand in the pdb</span>
<span class="sd">            :type resnum: int</span>
<span class="sd">            :param resChain: String containing the chain name of the ligand in the pdb</span>
<span class="sd">            :type resChain: str</span>
<span class="sd">            :param reportBaseFilename: Name of the file that contains the metrics of the snapshots to cluster</span>
<span class="sd">            :type reportBaseFilename: str</span>
<span class="sd">            :param columnOfReportFile: Column of the report file that contain the metric of interest</span>
<span class="sd">            :type columnOfReportFile: int</span>
<span class="sd">            :param contactThresholdDistance: Distance at wich a ligand atom and a protein atom are</span>
<span class="sd">                considered in contact(default 8)</span>
<span class="sd">            :type contactThresholdDistance: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="s2">&quot;BaseClass&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">Clusters</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">reportBaseFilename</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reportBaseFilename</span> <span class="o">=</span> <span class="n">reportBaseFilename</span> <span class="o">+</span> <span class="s2">&quot;_</span><span class="si">%d</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reportBaseFilename</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resname</span> <span class="o">=</span> <span class="n">resname</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resnum</span> <span class="o">=</span> <span class="n">resnum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resChain</span> <span class="o">=</span> <span class="n">resChain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">columnOfReportFile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contactThresholdDistance</span> <span class="o">=</span> <span class="n">contactThresholdDistance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symmetries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">altSelection</span> <span class="o">=</span> <span class="n">altSelection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conformationNetwork</span> <span class="o">=</span> <span class="n">ConformationNetwork</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Defining pickling interface to avoid problems when working with old</span>
        <span class="c1"># simulations if the properties of the clustering-related classes have</span>
        <span class="c1"># changed</span>
        <span class="n">state</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="s2">&quot;clusters&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">,</span>
                 <span class="s2">&quot;reportBaseFilename&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">reportBaseFilename</span><span class="p">,</span>
                 <span class="s2">&quot;resname&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="s2">&quot;resnum&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">resnum</span><span class="p">,</span>
                 <span class="s2">&quot;resChain&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">resChain</span><span class="p">,</span> <span class="s2">&quot;col&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">,</span>
                 <span class="s2">&quot;epoch&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span><span class="p">,</span> <span class="s2">&quot;symmetries&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetries</span><span class="p">,</span>
                 <span class="s2">&quot;conformationNetwork&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">conformationNetwork</span><span class="p">,</span>
                 <span class="s2">&quot;contactThresholdDistance&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">contactThresholdDistance</span><span class="p">,</span>
                 <span class="s2">&quot;altSelection&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">altSelection</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="c1"># Restore instance attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;clusters&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reportBaseFilename</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reportBaseFilename&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resname</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;resname&#39;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resnum</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;resnum&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resChain</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;resChain&#39;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;col&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contactThresholdDistance</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;contactThresholdDistance&#39;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symmetries</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;symmetries&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">altSelection</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;altSelection&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conformationNetwork</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;conformationNetwork&#39;</span><span class="p">,</span> <span class="n">ConformationNetwork</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;epoch&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Clustering: nClusters: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">cluster</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

<div class="viewcode-block" id="Clustering.setCol"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Clustering.setCol">[docs]</a>    <span class="k">def</span> <span class="nf">setCol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Set the column of the prefered column to col</span>

<span class="sd">            :param col: Column of the prefered column</span>
<span class="sd">            :type col: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span>

        <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">clusters</span><span class="p">:</span>
            <span class="n">cluster</span><span class="o">.</span><span class="n">metricCol</span> <span class="o">=</span> <span class="n">col</span></div>

<div class="viewcode-block" id="Clustering.getCluster"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Clustering.getCluster">[docs]</a>    <span class="k">def</span> <span class="nf">getCluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clusterNum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Get the cluster at index clusterNum</span>

<span class="sd">            :returns: :py:class:`.Cluster` -- Cluster at clusterNum</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">getCluster</span><span class="p">(</span><span class="n">clusterNum</span><span class="p">)</span></div>

<div class="viewcode-block" id="Clustering.emptyClustering"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Clustering.emptyClustering">[docs]</a>    <span class="k">def</span> <span class="nf">emptyClustering</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Delete previous results of clustering object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">Clusters</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conformationNetwork</span> <span class="o">=</span> <span class="n">ConformationNetwork</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span></div>

<div class="viewcode-block" id="Clustering.clusterIterator"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Clustering.clusterIterator">[docs]</a>    <span class="k">def</span> <span class="nf">clusterIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Iterator over the clusters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: may be interesting to add some condition to filter, check</span>
        <span class="c1"># itertools module, its probably implemented</span>
        <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">clusters</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">cluster</span></div>

<div class="viewcode-block" id="Clustering.getNumberClusters"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Clustering.getNumberClusters">[docs]</a>    <span class="k">def</span> <span class="nf">getNumberClusters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Get the number of clusters</span>

<span class="sd">            :returns: int -- Number of clusters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">getNumberClusters</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">clusters</span>\
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">reportBaseFilename</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">reportBaseFilename</span>\
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">resname</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">resname</span>\
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">resnum</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">resnum</span>\
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">resChain</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">resChain</span>\
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">col</span>

<div class="viewcode-block" id="Clustering.cluster"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Clustering.cluster">[docs]</a>    <span class="k">def</span> <span class="nf">cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">ignoreFirstRow</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">topology</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Cluster the snaptshots contained in the paths folder</span>

<span class="sd">            :param paths: List of folders with the snapshots</span>
<span class="sd">            :type paths: list</span>
<span class="sd">            :param topology: Topology file for non-pdb trajectories</span>
<span class="sd">            :type topology: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">topology</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">topology_contents</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">topology_contents</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">getTopologyFile</span><span class="p">(</span><span class="n">topology</span><span class="p">)</span>
        <span class="n">trajectories</span> <span class="o">=</span> <span class="n">getAllTrajectories</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">trajectory</span> <span class="ow">in</span> <span class="n">trajectories</span><span class="p">:</span>
            <span class="n">trajNum</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">getTrajNum</span><span class="p">(</span><span class="n">trajectory</span><span class="p">)</span>
            <span class="c1"># origCluster = processorsToClusterMapping[trajNum-1]</span>
            <span class="n">origCluster</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">snapshots</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">getSnapshots</span><span class="p">(</span><span class="n">trajectory</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">topology</span><span class="o">=</span><span class="n">topology</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reportBaseFilename</span><span class="p">:</span>
                <span class="n">reportFilename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">trajectory</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">reportBaseFilename</span> <span class="o">%</span> <span class="n">trajNum</span><span class="p">)</span>
                <span class="n">metrics</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">reportFilename</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">snapshot</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">snapshots</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">ignoreFirstRow</span> <span class="ow">and</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">origCluster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">addSnapshotToCluster</span><span class="p">(</span><span class="n">trajNum</span><span class="p">,</span> <span class="n">snapshot</span><span class="p">,</span> <span class="n">origCluster</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">metrics</span><span class="p">[</span><span class="n">num</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">topology</span><span class="o">=</span><span class="n">topology_contents</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot; in trajectory </span><span class="si">%d</span><span class="s2">. This is usually caused by a mismatch between report files and trajectory files&quot;</span>
                                   <span class="s2">&quot; which in turn is usually caused by some problem in writing the files, e.g. quota&quot;</span><span class="p">)</span>

                        <span class="c1"># raise a new exception of the same type, with the same</span>
                        <span class="c1"># traceback but with an added message</span>
                        <span class="n">raise_</span><span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">+</span> <span class="n">message</span> <span class="o">%</span> <span class="n">trajNum</span><span class="p">),</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">snapshot</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">snapshots</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">ignoreFirstRow</span> <span class="ow">and</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">origCluster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">addSnapshotToCluster</span><span class="p">(</span><span class="n">trajNum</span><span class="p">,</span> <span class="n">snapshot</span><span class="p">,</span> <span class="n">origCluster</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">topology</span><span class="o">=</span><span class="n">topology_contents</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">clusters</span><span class="p">:</span>
            <span class="n">cluster</span><span class="o">.</span><span class="n">altStructure</span><span class="o">.</span><span class="n">cleanPQ</span><span class="p">()</span></div>

<div class="viewcode-block" id="Clustering.writeOutput"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Clustering.writeOutput">[docs]</a>    <span class="k">def</span> <span class="nf">writeOutput</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputPath</span><span class="p">,</span> <span class="n">degeneracy</span><span class="p">,</span> <span class="n">outputObject</span><span class="p">,</span> <span class="n">writeAll</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Writes all the clustering information in outputPath</span>

<span class="sd">            :param outputPath: Folder that will contain all the clustering information</span>
<span class="sd">            :type outputPath: str</span>
<span class="sd">            :param degeneracy: Degeneracy of each cluster. It must be in the same order</span>
<span class="sd">                as in the self.clusters list</span>
<span class="sd">            :type degeneracy: list</span>
<span class="sd">            :param outputObject: Output name for the pickle object</span>
<span class="sd">            :type outputObject: str</span>
<span class="sd">            :param writeAll: Wether to write pdb files for all cluster in addition</span>
<span class="sd">                of the summary</span>
<span class="sd">            :type writeAll: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">utilities</span><span class="o">.</span><span class="n">cleanup</span><span class="p">(</span><span class="n">outputPath</span><span class="p">)</span>
        <span class="n">utilities</span><span class="o">.</span><span class="n">makeFolder</span><span class="p">(</span><span class="n">outputPath</span><span class="p">)</span>

        <span class="n">summaryFilename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outputPath</span><span class="p">,</span> <span class="s2">&quot;summary.txt&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">summaryFilename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">summaryFile</span><span class="p">:</span>
            <span class="n">summaryFile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;#cluster size degeneracy contacts threshold density metric</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">clusters</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">writeAll</span><span class="p">:</span>
                    <span class="n">outputFilename</span> <span class="o">=</span> <span class="s2">&quot;cluster_</span><span class="si">%d</span><span class="s2">.pdb&quot;</span> <span class="o">%</span> <span class="n">i</span>
                    <span class="n">outputFilename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outputPath</span><span class="p">,</span> <span class="n">outputFilename</span><span class="p">)</span>
                    <span class="n">cluster</span><span class="o">.</span><span class="n">writePDB</span><span class="p">(</span><span class="n">outputFilename</span><span class="p">)</span>

                <span class="n">metric</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">getMetric</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">metric</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">metric</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">metric</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">metric</span>
                <span class="n">degeneracy_cluster</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">degeneracy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># degeneracy will be None if null spawning is used</span>
                    <span class="n">degeneracy_cluster</span> <span class="o">=</span> <span class="n">degeneracy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="n">writeString</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%.2f</span><span class="s2"> </span><span class="si">%.4f</span><span class="s2"> </span><span class="si">%.1f</span><span class="s2"> </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cluster</span><span class="o">.</span><span class="n">elements</span><span class="p">,</span>
                                                                <span class="n">degeneracy_cluster</span><span class="p">,</span>
                                                                <span class="n">cluster</span><span class="o">.</span><span class="n">contacts</span><span class="p">,</span>
                                                                <span class="n">cluster</span><span class="o">.</span><span class="n">threshold</span><span class="p">,</span>
                                                                <span class="n">cluster</span><span class="o">.</span><span class="n">density</span> <span class="ow">or</span> <span class="mf">1.0</span><span class="p">,</span>
                                                                <span class="n">metric</span><span class="p">)</span>
                <span class="n">summaryFile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">writeString</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">outputObject</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="Clustering.addSnapshotToCluster"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Clustering.addSnapshotToCluster">[docs]</a>    <span class="k">def</span> <span class="nf">addSnapshotToCluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trajNum</span><span class="p">,</span> <span class="n">snapshot</span><span class="p">,</span> <span class="n">origCluster</span><span class="p">,</span> <span class="n">snapshotNum</span><span class="p">,</span> <span class="n">metrics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">topology</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Cluster a snapshot using the leader algorithm</span>

<span class="sd">            :param trajNum: Trajectory number</span>
<span class="sd">            :type trajNum: int</span>
<span class="sd">            :param snapshot: Snapshot to add</span>
<span class="sd">            :type snapshot: str</span>
<span class="sd">            :param origCluster: Cluster found in the previos snapshot</span>
<span class="sd">            :type origCluster: int</span>
<span class="sd">            :param snapshotNum: Number of snapshot in its trajectory</span>
<span class="sd">            :type snapshotNum: int</span>
<span class="sd">            :param metrics: Array with the metrics of the snapshot</span>
<span class="sd">            :type metrics: numpy.Array</span>
<span class="sd">            :param col: Column of the desired metrics</span>
<span class="sd">            :type col: int</span>
<span class="sd">            :returns: int -- Cluster to which the snapshot belongs</span>
<span class="sd">            :param topology: Topology for non-pdb trajectories</span>
<span class="sd">            :type topology: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">metrics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metrics</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pdb</span> <span class="o">=</span> <span class="n">atomset</span><span class="o">.</span><span class="n">PDB</span><span class="p">()</span>
        <span class="n">pdb</span><span class="o">.</span><span class="n">initialise</span><span class="p">(</span><span class="n">snapshot</span><span class="p">,</span> <span class="n">resname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="n">resnum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">resnum</span><span class="p">,</span> <span class="n">chain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">resChain</span><span class="p">,</span> <span class="n">topology</span><span class="o">=</span><span class="n">topology</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusteringEvaluator</span><span class="o">.</span><span class="n">cleanContactMap</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">clusterNum</span><span class="p">,</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">clusters</span><span class="p">):</span>
            <span class="n">scd</span> <span class="o">=</span> <span class="n">atomset</span><span class="o">.</span><span class="n">computeSquaredCentroidDifference</span><span class="p">(</span><span class="n">cluster</span><span class="o">.</span><span class="n">pdb</span><span class="p">,</span> <span class="n">pdb</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">scd</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusteringEvaluator</span><span class="o">.</span><span class="n">getInnerLimit</span><span class="p">(</span><span class="n">cluster</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">isSimilar</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusteringEvaluator</span><span class="o">.</span><span class="n">isElement</span><span class="p">(</span><span class="n">pdb</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span>
                                                                 <span class="bp">self</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resnum</span><span class="p">,</span>
                                                                 <span class="bp">self</span><span class="o">.</span><span class="n">resChain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contactThresholdDistance</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">isSimilar</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dist</span> <span class="o">&gt;</span> <span class="n">cluster</span><span class="o">.</span><span class="n">threshold</span><span class="o">/</span><span class="mf">2.0</span><span class="p">:</span>
                    <span class="n">cluster</span><span class="o">.</span><span class="n">altStructure</span><span class="o">.</span><span class="n">addStructure</span><span class="p">(</span><span class="n">pdb</span><span class="p">,</span> <span class="n">cluster</span><span class="o">.</span><span class="n">threshold</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resnum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resChain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contactThresholdDistance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusteringEvaluator</span><span class="p">,</span> <span class="n">trajPosition</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">epoch</span><span class="p">,</span> <span class="n">trajNum</span><span class="p">,</span> <span class="n">snapshotNum</span><span class="p">))</span>
                <span class="n">cluster</span><span class="o">.</span><span class="n">addElement</span><span class="p">(</span><span class="n">metrics</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">origCluster</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">origCluster</span> <span class="o">=</span> <span class="n">clusterNum</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">conformationNetwork</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">origCluster</span><span class="p">,</span> <span class="n">clusterNum</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">clusterNum</span>

        <span class="c1"># if made it here, the snapshot was not added into any cluster</span>
        <span class="c1"># Check if contacts and contactMap are set (depending on which kind</span>
        <span class="c1"># of clustering)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusteringEvaluator</span><span class="o">.</span><span class="n">checkAttributes</span><span class="p">(</span><span class="n">pdb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resnum</span><span class="p">,</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">resChain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contactThresholdDistance</span><span class="p">)</span>
        <span class="n">contacts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusteringEvaluator</span><span class="o">.</span><span class="n">contacts</span>
        <span class="n">numberOfLigandAtoms</span> <span class="o">=</span> <span class="n">pdb</span><span class="o">.</span><span class="n">getNumberOfAtoms</span><span class="p">()</span>
        <span class="n">contactsPerAtom</span> <span class="o">=</span> <span class="n">contacts</span><span class="o">/</span><span class="n">numberOfLigandAtoms</span>

        <span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">thresholdCalculator</span><span class="o">.</span><span class="n">calculate</span><span class="p">(</span><span class="n">contactsPerAtom</span><span class="p">)</span>
        <span class="n">cluster</span> <span class="o">=</span> <span class="n">Cluster</span><span class="p">(</span><span class="n">pdb</span><span class="p">,</span> <span class="n">thresholdRadius</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
                          <span class="n">contacts</span><span class="o">=</span><span class="n">contactsPerAtom</span><span class="p">,</span>
                          <span class="n">contactMap</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">clusteringEvaluator</span><span class="o">.</span><span class="n">contactMap</span><span class="p">,</span>
                          <span class="n">metrics</span><span class="o">=</span><span class="n">metrics</span><span class="p">,</span> <span class="n">metricCol</span><span class="o">=</span><span class="n">col</span><span class="p">,</span>
                          <span class="n">contactThreshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">contactThresholdDistance</span><span class="p">,</span>
                          <span class="n">altSelection</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">altSelection</span><span class="p">,</span> <span class="n">trajPosition</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">epoch</span><span class="p">,</span> <span class="n">trajNum</span><span class="p">,</span> <span class="n">snapshotNum</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">addCluster</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
        <span class="n">clusterNum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">getNumberClusters</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">clusterNum</span> <span class="o">==</span> <span class="n">origCluster</span> <span class="ow">or</span> <span class="n">origCluster</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">origCluster</span> <span class="o">=</span> <span class="n">clusterNum</span>
            <span class="c1"># The clusterNum should only be equal to origCluster when the first</span>
            <span class="c1"># cluster is created and the clusterInitialStructures function has</span>
            <span class="c1"># not been called, i.e. when usind the compareClustering script</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conformationNetwork</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">clusterNum</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="s1">&#39;root&#39;</span><span class="p">,</span> <span class="n">epoch</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">epoch</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conformationNetwork</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">clusterNum</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">origCluster</span><span class="p">,</span> <span class="n">epoch</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">epoch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conformationNetwork</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">origCluster</span><span class="p">,</span> <span class="n">clusterNum</span><span class="p">)</span>
        <span class="c1"># If a new cluster is discovered during a trajectory, the next step in</span>
        <span class="c1"># the same trajectory will be considered to start from these new</span>
        <span class="c1"># cluster, thus resulting in a more precise conformation network and</span>
        <span class="c1"># smoother pathways</span>
        <span class="k">return</span> <span class="n">clusterNum</span></div>

<div class="viewcode-block" id="Clustering.writeClusterMetric"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Clustering.writeClusterMetric">[docs]</a>    <span class="k">def</span> <span class="nf">writeClusterMetric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">metricCol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Write the metric of each node in the conformation network in a</span>
<span class="sd">            tab-separated file</span>

<span class="sd">            :param path: Path where to write the network</span>
<span class="sd">            :type path: str</span>
<span class="sd">            :param metricCol: Column of the metric of interest</span>
<span class="sd">            :type metricCol: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">clusters</span><span class="p">):</span>
                <span class="n">metric</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">getMetricFromColumn</span><span class="p">(</span><span class="n">metricCol</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">metric</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="se">\t</span><span class="s2">-</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="se">\t</span><span class="si">%.4f</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">metric</span><span class="p">))</span></div>

<div class="viewcode-block" id="Clustering.writeConformationNodePopulation"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Clustering.writeConformationNodePopulation">[docs]</a>    <span class="k">def</span> <span class="nf">writeConformationNodePopulation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Write the population of each node in the conformation network in a</span>
<span class="sd">            tab-separated file</span>

<span class="sd">            :param path: Path where to write the network</span>
<span class="sd">            :type path: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">clusters</span><span class="p">):</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="se">\t</span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cluster</span><span class="o">.</span><span class="n">elements</span><span class="p">))</span></div>

<div class="viewcode-block" id="Clustering.getOptimalMetric"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Clustering.getOptimalMetric">[docs]</a>    <span class="k">def</span> <span class="nf">getOptimalMetric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">simulationType</span><span class="o">=</span><span class="s2">&quot;min&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Find the cluster with the best metric</span>

<span class="sd">            :param column: Column of the metric that defines the best cluster,</span>
<span class="sd">                if not specified, the cluster metric is chosen</span>
<span class="sd">            :type column: int</span>
<span class="sd">            :param simulationType: Define optimal metric as the maximum or minimum, max or min</span>
<span class="sd">            :type simulationType: str</span>

<span class="sd">            :returns: int -- Number of cluster with the optimal metric</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">metrics</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">clusters</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">metric</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">getMetric</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">metric</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">getMetricFromColumn</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
            <span class="n">metrics</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">simulationType</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;min&quot;</span><span class="p">:</span>
            <span class="n">optimalMetricIndex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">metrics</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">simulationType</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;max&quot;</span><span class="p">:</span>
            <span class="n">optimalMetricIndex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">metrics</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized type simulation parameter!!! Possible values are max or min&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">optimalMetricIndex</span></div>

<div class="viewcode-block" id="Clustering.writePathwayTrajectory"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Clustering.writePathwayTrajectory">[docs]</a>    <span class="k">def</span> <span class="nf">writePathwayTrajectory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pathway</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">topology</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Write a list of cluster forming a pathway into a trajectory pdb file</span>

<span class="sd">            :param pathway: List of clusters that form the pathway</span>
<span class="sd">            :type pathway: list</span>
<span class="sd">            :param filename: Path where to write the trajectory</span>
<span class="sd">            :type filename: str</span>
<span class="sd">            :param topology: Lines of topology file</span>
<span class="sd">            :type topology: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">topology</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">topology</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">pathwayFile</span><span class="p">:</span>
            <span class="n">pathwayFile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;REMARK 000 File created using PELE++</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">pathwayFile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;REMARK 000 Pathway trajectory created using the FDT</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">pathwayFile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;REMARK 000 List of cluster belonging to the pathway </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">pathway</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">step_cluster</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pathway</span><span class="p">):</span>
                <span class="n">cluster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">step_cluster</span><span class="p">]</span>
                <span class="n">pathwayFile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;MODEL </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">pdbStr</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">pdb</span><span class="o">.</span><span class="n">get_pdb_string</span><span class="p">()</span>
                <span class="n">pdbList</span> <span class="o">=</span> <span class="n">pdbStr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">pdbList</span><span class="p">:</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                    <span class="c1"># Avoid writing previous REMARK block</span>
                    <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;REMARK &quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;MODEL &quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">line</span> <span class="o">==</span> <span class="s2">&quot;END&quot;</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">elif</span> <span class="n">line</span><span class="p">:</span>
                        <span class="n">pathwayFile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">pathwayFile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;ENDMDL</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Clustering.writePathwayOptimalCluster"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.Clustering.writePathwayOptimalCluster">[docs]</a>    <span class="k">def</span> <span class="nf">writePathwayOptimalCluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Extract the pathway to the cluster with the best metric as a</span>
<span class="sd">            trajectory and  write it to a PDB file</span>

<span class="sd">            :param filename: Path where to write the trajectory</span>
<span class="sd">            :type filename: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">optimalCluster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOptimalMetric</span><span class="p">()</span>
        <span class="n">pathway</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">createPathwayToCluster</span><span class="p">(</span><span class="n">optimalCluster</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writePathwayTrajectory</span><span class="p">(</span><span class="n">pathway</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ContactsClustering"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.ContactsClustering">[docs]</a><span class="k">class</span> <span class="nc">ContactsClustering</span><span class="p">(</span><span class="n">Clustering</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thresholdCalculator</span><span class="p">,</span> <span class="n">resname</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">resnum</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">resChain</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                 <span class="n">reportBaseFilename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">columnOfReportFile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">contactThresholdDistance</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">symmetries</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">altSelection</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Cluster together all snapshots that are closer to the cluster center</span>
<span class="sd">            than certain threshold. This threshold is assigned according to the</span>
<span class="sd">            ratio of number of contacts over the number of heavy atoms of the ligand</span>

<span class="sd">            :param resname: String containing the three letter name of the ligand in the pdb</span>
<span class="sd">            :type resname: str</span>
<span class="sd">            :param resnum: Integer containing the residue number of the ligand in the pdb</span>
<span class="sd">            :type resnum: int</span>
<span class="sd">            :param resChain: String containing the chain name of the ligand in the pdb</span>
<span class="sd">            :type resChain: str</span>
<span class="sd">            :param thresholdCalculator: ThresholdCalculator object that calculate the</span>
<span class="sd">                threshold according to the contacts ratio</span>
<span class="sd">            :type thresholdCalculator: :py:class:`.ThresholdCalculator`</span>
<span class="sd">            :param reportBaseFilename: Name of the file that contains the metrics of</span>
<span class="sd">                the snapshots to cluster</span>
<span class="sd">            :type reportBaseFilename: str</span>
<span class="sd">            :param columnOfReportFile: Column of the report file that contain the</span>
<span class="sd">                metric of interest</span>
<span class="sd">            :type columnOfReportFile: int</span>
<span class="sd">            :param contactThresholdDistance: Distance at wich a ligand atom and a protein atom are</span>
<span class="sd">                considered in contact(default 8)</span>
<span class="sd">            :type contactThresholdDistance: float</span>
<span class="sd">            :param symmetries: List of symmetric groups</span>
<span class="sd">            :type symmetries: list</span>
<span class="sd">            :param altSelection: Flag that controls wether to use the alternative structures (default 8)</span>
<span class="sd">            :type altSelection: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Clustering</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resname</span><span class="o">=</span><span class="n">resname</span><span class="p">,</span> <span class="n">resnum</span><span class="o">=</span><span class="n">resnum</span><span class="p">,</span> <span class="n">resChain</span><span class="o">=</span><span class="n">resChain</span><span class="p">,</span>
                            <span class="n">reportBaseFilename</span><span class="o">=</span><span class="n">reportBaseFilename</span><span class="p">,</span>
                            <span class="n">columnOfReportFile</span><span class="o">=</span><span class="n">columnOfReportFile</span><span class="p">,</span>
                            <span class="n">contactThresholdDistance</span><span class="o">=</span><span class="n">contactThresholdDistance</span><span class="p">,</span>
                            <span class="n">altSelection</span><span class="o">=</span><span class="n">altSelection</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">clusteringTypes</span><span class="o">.</span><span class="n">CLUSTERING_TYPES</span><span class="o">.</span><span class="n">rmsd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thresholdCalculator</span> <span class="o">=</span> <span class="n">thresholdCalculator</span>
        <span class="k">if</span> <span class="n">symmetries</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">symmetries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symmetries</span> <span class="o">=</span> <span class="n">symmetries</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusteringEvaluator</span> <span class="o">=</span> <span class="n">ContactsClusteringEvaluator</span><span class="p">(</span><span class="n">RMSDCalculator</span><span class="o">.</span><span class="n">RMSDCalculator</span><span class="p">(</span><span class="n">symmetries</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Defining pickling interface to avoid problems when working with old</span>
        <span class="c1"># simulations if the properties of the clustering-related classes have</span>
        <span class="c1"># changed</span>
        <span class="n">state</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="s2">&quot;clusters&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">,</span>
                 <span class="s2">&quot;reportBaseFilename&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">reportBaseFilename</span><span class="p">,</span>
                 <span class="s2">&quot;resname&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="s2">&quot;resnum&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">resnum</span><span class="p">,</span>
                 <span class="s2">&quot;resChain&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">resChain</span><span class="p">,</span> <span class="s2">&quot;col&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">,</span>
                 <span class="s2">&quot;epoch&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span><span class="p">,</span>
                 <span class="s2">&quot;symmetries&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetries</span><span class="p">,</span>
                 <span class="s2">&quot;conformationNetwork&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">conformationNetwork</span><span class="p">,</span>
                 <span class="s2">&quot;contactThresholdDistance&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">contactThresholdDistance</span><span class="p">,</span>
                 <span class="s2">&quot;altSelection&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">altSelection</span><span class="p">,</span>
                 <span class="s2">&quot;thresholdCalculator&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">thresholdCalculator</span><span class="p">,</span>
                 <span class="s2">&quot;clusteringEvaluator&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusteringEvaluator</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="c1"># Restore instance attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;clusters&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reportBaseFilename</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reportBaseFilename&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resname</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;resname&#39;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resnum</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;resnum&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resChain</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;resChain&#39;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;col&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contactThresholdDistance</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;contactThresholdDistance&#39;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symmetries</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;symmetries&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">altSelection</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;altSelection&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conformationNetwork</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;conformationNetwork&#39;</span><span class="p">,</span> <span class="n">ConformationNetwork</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;epoch&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thresholdCalculator</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;thresholdCalculator&#39;</span><span class="p">,</span> <span class="n">thresholdcalculator</span><span class="o">.</span><span class="n">ThresholdCalculatorConstant</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symmetries</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symmetries</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">symmetries</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusteringEvaluator</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;clusteringEvaluator&#39;</span><span class="p">,</span> <span class="n">ContactsClusteringEvaluator</span><span class="p">(</span><span class="n">RMSDCalculator</span><span class="o">.</span><span class="n">RMSDCalculator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symmetries</span><span class="p">)))</span></div>


<div class="viewcode-block" id="ContactMapAccumulativeClustering"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.ContactMapAccumulativeClustering">[docs]</a><span class="k">class</span> <span class="nc">ContactMapAccumulativeClustering</span><span class="p">(</span><span class="n">Clustering</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thresholdCalculator</span><span class="p">,</span> <span class="n">similarityEvaluator</span><span class="p">,</span> <span class="n">resname</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                 <span class="n">resnum</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">resChain</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                 <span class="n">reportBaseFilename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">columnOfReportFile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">contactThresholdDistance</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">symmetries</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">altSelection</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Cluster together all snapshots that have similar enough contactMaps.</span>
<span class="sd">            This similarity can be calculated with different methods (see similariyEvaluator documentation)</span>

<span class="sd">            :param thresholdCalculator: ThresholdCalculator object that calculate the</span>
<span class="sd">                threshold according to the contacts ratio</span>
<span class="sd">            :type thresholdCalculator: :py:class:`.ThresholdCalculator`</span>
<span class="sd">            :param similarityEvaluator: object that calculates the similarity</span>
<span class="sd">                between two contact maps</span>
<span class="sd">            :type similarityEvaluator: object</span>
<span class="sd">            :param resname: String containing the three letter name of the ligand in the pdb</span>
<span class="sd">            :type resname: str</span>
<span class="sd">            :param resnum: Integer containing the residue number of the ligand in the pdb</span>
<span class="sd">            :type resnum: int</span>
<span class="sd">            :param resChain: String containing the chain name of the ligand in the pdb</span>
<span class="sd">            :type resChain: str</span>
<span class="sd">            :param reportBaseFilename: Name of the file that contains the metrics of</span>
<span class="sd">                the snapshots to cluster</span>
<span class="sd">            :type reportBaseFilename: str</span>
<span class="sd">            :param columnOfReportFile: Column of the report file that contain the</span>
<span class="sd">                metric of interest</span>
<span class="sd">            :type columnOfReportFile: int</span>
<span class="sd">            :param contactThresholdDistance: Distance at wich a ligand atom and a protein atom are</span>
<span class="sd">                considered in contact(default 8)</span>
<span class="sd">            :type contactThresholdDistance: float</span>
<span class="sd">            :param symmetries: List of symmetric groups</span>
<span class="sd">            :type symmetries: list</span>
<span class="sd">            :param altSelection: Flag that controls wether to use the alternative structures (default 8)</span>
<span class="sd">            :type altSelection: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">symmetries</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">symmetries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">Clustering</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resname</span><span class="o">=</span><span class="n">resname</span><span class="p">,</span> <span class="n">resnum</span><span class="o">=</span><span class="n">resnum</span><span class="p">,</span> <span class="n">resChain</span><span class="o">=</span><span class="n">resChain</span><span class="p">,</span>
                            <span class="n">reportBaseFilename</span><span class="o">=</span><span class="n">reportBaseFilename</span><span class="p">,</span>
                            <span class="n">columnOfReportFile</span><span class="o">=</span><span class="n">columnOfReportFile</span><span class="p">,</span>
                            <span class="n">contactThresholdDistance</span><span class="o">=</span><span class="n">contactThresholdDistance</span><span class="p">,</span>
                            <span class="n">altSelection</span><span class="o">=</span><span class="n">altSelection</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">clusteringTypes</span><span class="o">.</span><span class="n">CLUSTERING_TYPES</span><span class="o">.</span><span class="n">contactMap</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thresholdCalculator</span> <span class="o">=</span> <span class="n">thresholdCalculator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">similarityEvaluator</span> <span class="o">=</span> <span class="n">similarityEvaluator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symmetryEvaluator</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">SymmetryContactMapEvaluator</span><span class="p">(</span><span class="n">symmetries</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusteringEvaluator</span> <span class="o">=</span> <span class="n">CMClusteringEvaluator</span><span class="p">(</span><span class="n">similarityEvaluator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetryEvaluator</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Defining pickling interface to avoid problems when working with old</span>
        <span class="c1"># simulations if the properties of the clustering-related classes have</span>
        <span class="c1"># changed</span>
        <span class="n">state</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="s2">&quot;clusters&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">,</span>
                 <span class="s2">&quot;reportBaseFilename&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">reportBaseFilename</span><span class="p">,</span>
                 <span class="s2">&quot;resname&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="s2">&quot;resnum&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">resnum</span><span class="p">,</span>
                 <span class="s2">&quot;resChain&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">resChain</span><span class="p">,</span> <span class="s2">&quot;col&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">,</span>
                 <span class="s2">&quot;epoch&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span><span class="p">,</span> <span class="s2">&quot;symmetries&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetries</span><span class="p">,</span>
                 <span class="s2">&quot;conformationNetwork&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">conformationNetwork</span><span class="p">,</span>
                 <span class="s2">&quot;contactThresholdDistance&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">contactThresholdDistance</span><span class="p">,</span>
                 <span class="s2">&quot;altSelection&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">altSelection</span><span class="p">,</span>
                 <span class="s2">&quot;thresholdCalculator&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">thresholdCalculator</span><span class="p">,</span>
                 <span class="s2">&quot;similariyEvaluator&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">similarityEvaluator</span><span class="p">,</span>
                 <span class="s2">&quot;symmetryEvaluator&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetryEvaluator</span><span class="p">,</span>
                 <span class="s2">&quot;clusteringEvaluator&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusteringEvaluator</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="c1"># Restore instance attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;clusters&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reportBaseFilename</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reportBaseFilename&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resname</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;resname&#39;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resnum</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;resnum&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resChain</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;resChain&#39;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;col&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contactThresholdDistance</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;contactThresholdDistance&#39;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symmetries</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;symmetries&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">altSelection</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;altSelection&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conformationNetwork</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;conformationNetwork&#39;</span><span class="p">,</span> <span class="n">ConformationNetwork</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;epoch&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thresholdCalculator</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;thresholdCalculator&#39;</span><span class="p">,</span> <span class="n">thresholdcalculator</span><span class="o">.</span><span class="n">ThresholdCalculatorConstant</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mf">0.3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">similarityEvaluator</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;similariyEvaluator&#39;</span><span class="p">,</span> <span class="n">CMSimilarityEvaluator</span><span class="p">(</span><span class="n">blockNames</span><span class="o">.</span><span class="n">ClusteringTypes</span><span class="o">.</span><span class="n">Jaccard</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symmetryEvaluator</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;symmetryEvaluator&#39;</span><span class="p">,</span> <span class="n">sym</span><span class="o">.</span><span class="n">SymmetryContactMapEvaluator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symmetries</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusteringEvaluator</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;clusteringEvaluator&#39;</span><span class="p">,</span> <span class="n">CMClusteringEvaluator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">similarityEvaluator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetryEvaluator</span><span class="p">))</span></div>


<div class="viewcode-block" id="SequentialLastSnapshotClustering"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.SequentialLastSnapshotClustering">[docs]</a><span class="k">class</span> <span class="nc">SequentialLastSnapshotClustering</span><span class="p">(</span><span class="n">Clustering</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assigned  the last snapshot of the trajectory to a cluster.</span>
<span class="sd">        Only useful for PELE sequential runs</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SequentialLastSnapshotClustering.cluster"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.SequentialLastSnapshotClustering.cluster">[docs]</a>    <span class="k">def</span> <span class="nf">cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">topology</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Cluster the snaptshots contained in the paths folder</span>

<span class="sd">            :param paths: List of folders with the snapshots</span>
<span class="sd">            :type paths: list</span>
<span class="sd">            :param topology: Topology file for non-pdb trajectories</span>
<span class="sd">            :type topology: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Clean clusters at every step, so we only have the last snapshot of</span>
        <span class="c1"># each trajectory as clusters</span>
        <span class="k">if</span> <span class="n">topology</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">topology_contents</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">topology_contents</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">getTopologyFile</span><span class="p">(</span><span class="n">topology</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">Clusters</span><span class="p">()</span>
        <span class="n">trajectories</span> <span class="o">=</span> <span class="n">getAllTrajectories</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">trajectory</span> <span class="ow">in</span> <span class="n">trajectories</span><span class="p">:</span>
            <span class="n">trajNum</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">getTrajNum</span><span class="p">(</span><span class="n">trajectory</span><span class="p">)</span>

            <span class="n">snapshots</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">getSnapshots</span><span class="p">(</span><span class="n">trajectory</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">topology</span><span class="o">=</span><span class="n">topology</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reportBaseFilename</span><span class="p">:</span>
                <span class="n">reportFilename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">trajectory</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">reportBaseFilename</span> <span class="o">%</span> <span class="n">trajNum</span><span class="p">)</span>
                <span class="n">metrics</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">reportFilename</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="c1"># Pass as cluster metrics the minimum value for each metric,</span>
                <span class="c1"># thus the metrics are not valid to do any spawning, only to</span>
                <span class="c1"># check the exit condition</span>
                <span class="n">metrics</span> <span class="o">=</span> <span class="n">metrics</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">addSnapshotToCluster</span><span class="p">(</span><span class="n">snapshots</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">metrics</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">topology</span><span class="o">=</span><span class="n">topology_contents</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">addSnapshotToCluster</span><span class="p">(</span><span class="n">snapshots</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">topology</span><span class="o">=</span><span class="n">topology_contents</span><span class="p">)</span></div>

<div class="viewcode-block" id="SequentialLastSnapshotClustering.addSnapshotToCluster"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.SequentialLastSnapshotClustering.addSnapshotToCluster">[docs]</a>    <span class="k">def</span> <span class="nf">addSnapshotToCluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">snapshot</span><span class="p">,</span> <span class="n">metrics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">topology</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Cluster a snapshot using the leader algorithm</span>

<span class="sd">            :param trajNum: Trajectory number</span>
<span class="sd">            :type trajNum: int</span>
<span class="sd">            :param snapshot: Snapshot to add</span>
<span class="sd">            :type snapshot: str</span>
<span class="sd">            :param metrics: Array with the metrics of the snapshot</span>
<span class="sd">            :type metrics: numpy.Array</span>
<span class="sd">            :param col: Column of the desired metrics</span>
<span class="sd">            :type col: int</span>
<span class="sd">            :returns: int -- Cluster to which the snapshot belongs</span>
<span class="sd">            :param topology: Topology for non-pdb trajectories</span>
<span class="sd">            :type topology: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">metrics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metrics</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pdb</span> <span class="o">=</span> <span class="n">atomset</span><span class="o">.</span><span class="n">PDB</span><span class="p">()</span>
        <span class="n">pdb</span><span class="o">.</span><span class="n">initialise</span><span class="p">(</span><span class="n">snapshot</span><span class="p">,</span> <span class="n">resname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="n">resnum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">resnum</span><span class="p">,</span>
                       <span class="n">chain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">resChain</span><span class="p">,</span> <span class="n">topology</span><span class="o">=</span><span class="n">topology</span><span class="p">)</span>
        <span class="n">contacts</span> <span class="o">=</span> <span class="n">pdb</span><span class="o">.</span><span class="n">countContacts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contactThresholdDistance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resnum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resChain</span><span class="p">)</span>
        <span class="n">numberOfLigandAtoms</span> <span class="o">=</span> <span class="n">pdb</span><span class="o">.</span><span class="n">getNumberOfAtoms</span><span class="p">()</span>
        <span class="n">contactsPerAtom</span> <span class="o">=</span> <span class="n">contacts</span><span class="o">/</span><span class="n">numberOfLigandAtoms</span>

        <span class="n">cluster</span> <span class="o">=</span> <span class="n">Cluster</span><span class="p">(</span><span class="n">pdb</span><span class="p">,</span> <span class="n">thresholdRadius</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                          <span class="n">contacts</span><span class="o">=</span><span class="n">contactsPerAtom</span><span class="p">,</span> <span class="n">metrics</span><span class="o">=</span><span class="n">metrics</span><span class="p">,</span>
                          <span class="n">metricCol</span><span class="o">=</span><span class="n">col</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">addCluster</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ClusteringBuilder"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.ClusteringBuilder">[docs]</a><span class="k">class</span> <span class="nc">ClusteringBuilder</span><span class="p">:</span>
<div class="viewcode-block" id="ClusteringBuilder.buildClustering"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.ClusteringBuilder.buildClustering">[docs]</a>    <span class="k">def</span> <span class="nf">buildClustering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clusteringBlock</span><span class="p">,</span> <span class="n">reportBaseFilename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">columnOfReportFile</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Builder to create the appropiate clustering object</span>

<span class="sd">            :param clusteringBlock: Parameters of the clustering process</span>
<span class="sd">            :type clusteringBlock: dict</span>
<span class="sd">            :param reportBaseFilename: Name of the file that contains the metrics of</span>
<span class="sd">                the snapshots to cluster</span>
<span class="sd">            :type reportBaseFilename: str</span>
<span class="sd">            :param columnOfReportFile: Column of the report file that contain the</span>
<span class="sd">                metric of interest</span>
<span class="sd">            :type columnOfReportFile: int</span>
<span class="sd">            :returns: :py:class:`.Clustering` -- Clustering object selected</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">paramsBlock</span> <span class="o">=</span> <span class="n">clusteringBlock</span><span class="p">[</span><span class="n">blockNames</span><span class="o">.</span><span class="n">ClusteringTypes</span><span class="o">.</span><span class="n">params</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">clusteringType</span> <span class="o">=</span> <span class="n">clusteringBlock</span><span class="p">[</span><span class="n">blockNames</span><span class="o">.</span><span class="n">ClusteringTypes</span><span class="o">.</span><span class="n">type</span><span class="p">]</span>
            <span class="n">contactThresholdDistance</span> <span class="o">=</span> <span class="n">paramsBlock</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">blockNames</span><span class="o">.</span><span class="n">ClusteringTypes</span><span class="o">.</span><span class="n">contactThresholdDistance</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
            <span class="n">altSelection</span> <span class="o">=</span> <span class="n">paramsBlock</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">blockNames</span><span class="o">.</span><span class="n">ClusteringTypes</span><span class="o">.</span><span class="n">alternativeStructure</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="n">err</span><span class="o">.</span><span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;: Need to provide mandatory parameter in clustering block&quot;</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">err</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
        <span class="n">resname</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">paramsBlock</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">blockNames</span><span class="o">.</span><span class="n">ClusteringTypes</span><span class="o">.</span><span class="n">ligandResname</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="n">resnum</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">paramsBlock</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">blockNames</span><span class="o">.</span><span class="n">ClusteringTypes</span><span class="o">.</span><span class="n">ligandResnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">resChain</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">paramsBlock</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">blockNames</span><span class="o">.</span><span class="n">ClusteringTypes</span><span class="o">.</span><span class="n">ligandChain</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">clusteringType</span> <span class="o">==</span> <span class="n">blockNames</span><span class="o">.</span><span class="n">ClusteringTypes</span><span class="o">.</span><span class="n">rmsd</span><span class="p">:</span>
            <span class="n">symmetries</span> <span class="o">=</span> <span class="n">paramsBlock</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">blockNames</span><span class="o">.</span><span class="n">ClusteringTypes</span><span class="o">.</span><span class="n">symmetries</span><span class="p">,</span> <span class="p">[])</span>

            <span class="n">thresholdCalculatorBuilder</span> <span class="o">=</span> <span class="n">thresholdcalculator</span><span class="o">.</span><span class="n">ThresholdCalculatorBuilder</span><span class="p">()</span>
            <span class="n">thresholdCalculator</span> <span class="o">=</span> <span class="n">thresholdCalculatorBuilder</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">clusteringBlock</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ContactsClustering</span><span class="p">(</span><span class="n">thresholdCalculator</span><span class="p">,</span> <span class="n">resname</span><span class="o">=</span><span class="n">resname</span><span class="p">,</span> <span class="n">resnum</span><span class="o">=</span><span class="n">resnum</span><span class="p">,</span> <span class="n">resChain</span><span class="o">=</span><span class="n">resChain</span><span class="p">,</span>
                                      <span class="n">reportBaseFilename</span><span class="o">=</span><span class="n">reportBaseFilename</span><span class="p">,</span> <span class="n">columnOfReportFile</span><span class="o">=</span><span class="n">columnOfReportFile</span><span class="p">,</span>
                                      <span class="n">contactThresholdDistance</span><span class="o">=</span><span class="n">contactThresholdDistance</span><span class="p">,</span> <span class="n">symmetries</span><span class="o">=</span><span class="n">symmetries</span><span class="p">,</span>
                                      <span class="n">altSelection</span><span class="o">=</span><span class="n">altSelection</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">clusteringType</span> <span class="o">==</span> <span class="n">blockNames</span><span class="o">.</span><span class="n">ClusteringTypes</span><span class="o">.</span><span class="n">lastSnapshot</span><span class="p">:</span>

            <span class="k">return</span> <span class="n">SequentialLastSnapshotClustering</span><span class="p">(</span><span class="n">resname</span><span class="o">=</span><span class="n">resname</span><span class="p">,</span> <span class="n">resnum</span><span class="o">=</span><span class="n">resnum</span><span class="p">,</span> <span class="n">resChain</span><span class="o">=</span><span class="n">resChain</span><span class="p">,</span>
                                                    <span class="n">reportBaseFilename</span><span class="o">=</span><span class="n">reportBaseFilename</span><span class="p">,</span>
                                                    <span class="n">columnOfReportFile</span><span class="o">=</span><span class="n">columnOfReportFile</span><span class="p">,</span>
                                                    <span class="n">contactThresholdDistance</span><span class="o">=</span><span class="n">contactThresholdDistance</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">clusteringType</span> <span class="o">==</span> <span class="n">blockNames</span><span class="o">.</span><span class="n">ClusteringTypes</span><span class="o">.</span><span class="n">contactMap</span><span class="p">:</span>
            <span class="n">symmetries</span> <span class="o">=</span> <span class="n">paramsBlock</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">blockNames</span><span class="o">.</span><span class="n">ClusteringTypes</span><span class="o">.</span><span class="n">symmetries</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">thresholdCalculatorBuilder</span> <span class="o">=</span> <span class="n">thresholdcalculator</span><span class="o">.</span><span class="n">ThresholdCalculatorBuilder</span><span class="p">()</span>
            <span class="n">thresholdCalculator</span> <span class="o">=</span> <span class="n">thresholdCalculatorBuilder</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">clusteringBlock</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">similarityEvaluatorType</span> <span class="o">=</span> <span class="n">paramsBlock</span><span class="p">[</span><span class="n">blockNames</span><span class="o">.</span><span class="n">ClusteringTypes</span><span class="o">.</span><span class="n">similarityEvaluator</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No similarity Evaluator specified!!&quot;</span><span class="p">)</span>
            <span class="n">similarityBuilder</span> <span class="o">=</span> <span class="n">similarityEvaluatorBuilder</span><span class="p">()</span>
            <span class="n">similarityEvaluator</span> <span class="o">=</span> <span class="n">similarityBuilder</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">similarityEvaluatorType</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ContactMapAccumulativeClustering</span><span class="p">(</span><span class="n">thresholdCalculator</span><span class="p">,</span> <span class="n">similarityEvaluator</span><span class="p">,</span> <span class="n">resname</span><span class="o">=</span><span class="n">resname</span><span class="p">,</span>
                                                    <span class="n">resnum</span><span class="o">=</span><span class="n">resnum</span><span class="p">,</span> <span class="n">resChain</span><span class="o">=</span><span class="n">resChain</span><span class="p">,</span>
                                                    <span class="n">reportBaseFilename</span><span class="o">=</span><span class="n">reportBaseFilename</span><span class="p">,</span> <span class="n">columnOfReportFile</span><span class="o">=</span><span class="n">columnOfReportFile</span><span class="p">,</span>
                                                    <span class="n">contactThresholdDistance</span><span class="o">=</span><span class="n">contactThresholdDistance</span><span class="p">,</span> <span class="n">symmetries</span><span class="o">=</span><span class="n">symmetries</span><span class="p">,</span> <span class="n">altSelection</span><span class="o">=</span><span class="n">altSelection</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Unknown clustering method! Choices are: &quot;</span> <span class="o">+</span>
                     <span class="nb">str</span><span class="p">(</span><span class="n">clusteringTypes</span><span class="o">.</span><span class="n">CLUSTERING_TYPE_TO_STRING_DICTIONARY</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span></div></div>


<div class="viewcode-block" id="similarityEvaluatorBuilder"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.similarityEvaluatorBuilder">[docs]</a><span class="k">class</span> <span class="nc">similarityEvaluatorBuilder</span><span class="p">:</span>
<div class="viewcode-block" id="similarityEvaluatorBuilder.build"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.similarityEvaluatorBuilder.build">[docs]</a>    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">similarityEvaluatorType</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Builder to create the appropiate similarityEvaluator</span>

<span class="sd">            :param similarityEvaluatorType: Type of similarityEvaluator chosen</span>
<span class="sd">            :type similarityEvaluatorType: str</span>
<span class="sd">            :returns: :py:class:`.SimilarityEvaluator` -- SimilarityEvaluator object selected</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">similarityEvaluatorType</span> <span class="ow">in</span> <span class="n">clusteringTypes</span><span class="o">.</span><span class="n">SIMILARITY_TYPES_NAMES</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">CMSimilarityEvaluator</span><span class="p">(</span><span class="n">similarityEvaluatorType</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Unknown threshold calculator type! Choices are: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">clusteringTypes</span><span class="o">.</span><span class="n">SIMILARITY_TYPES_TO_STRING_DICTIONARY</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span></div></div>


<div class="viewcode-block" id="CMSimilarityEvaluator"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.CMSimilarityEvaluator">[docs]</a><span class="k">class</span> <span class="nc">CMSimilarityEvaluator</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the similarity of two contactMaps by calculating the ratio of</span>
<span class="sd">        the number of differences over the average of elements in the contacts</span>
<span class="sd">        maps, their correlation or their Jaccard index, that is, the ratio</span>
<span class="sd">        between the intersection of the two contact maps and their union</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeEvaluator</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typeEvaluator</span> <span class="o">=</span> <span class="n">typeEvaluator</span>

<div class="viewcode-block" id="CMSimilarityEvaluator.isSimilarCluster"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.CMSimilarityEvaluator.isSimilarCluster">[docs]</a>    <span class="k">def</span> <span class="nf">isSimilarCluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">contactMap</span><span class="p">,</span> <span class="n">clusterContactMap</span><span class="p">,</span> <span class="n">symContactMapEvaluator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Evaluate if two contactMaps are similar or not, return True if yes,</span>
<span class="sd">            False otherwise</span>

<span class="sd">            :param contactMap: contactMap of the structure to compare</span>
<span class="sd">            :type contactMap: numpy.Array</span>
<span class="sd">            :param contactMap: contactMap of the structure to compare</span>
<span class="sd">            :type contactMap: numpy.Array</span>
<span class="sd">            :param symContactMapEvaluator: Contact Map symmetry evaluator object</span>
<span class="sd">            :type symContactMapEvaluator: :py:class:`.SymmetryContactMapEvaluator`</span>
<span class="sd">            :returns: float -- distance between contact maps</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typeEvaluator</span> <span class="o">==</span> <span class="n">blockNames</span><span class="o">.</span><span class="n">ClusteringTypes</span><span class="o">.</span><span class="n">correlation</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">symContactMapEvaluator</span><span class="o">.</span><span class="n">evaluateCorrelation</span><span class="p">(</span><span class="n">contactMap</span><span class="p">,</span> <span class="n">clusterContactMap</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">typeEvaluator</span> <span class="o">==</span> <span class="n">blockNames</span><span class="o">.</span><span class="n">ClusteringTypes</span><span class="o">.</span><span class="n">Jaccard</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">symContactMapEvaluator</span><span class="o">.</span><span class="n">evaluateJaccard</span><span class="p">(</span><span class="n">contactMap</span><span class="p">,</span> <span class="n">clusterContactMap</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">typeEvaluator</span> <span class="o">==</span> <span class="n">blockNames</span><span class="o">.</span><span class="n">ClusteringTypes</span><span class="o">.</span><span class="n">differenceDistance</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">symContactMapEvaluator</span><span class="o">.</span><span class="n">evaluateDifferenceDistance</span><span class="p">(</span><span class="n">contactMap</span><span class="p">,</span> <span class="n">clusterContactMap</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Evaluator type </span><span class="si">%s</span><span class="s2"> not found!!&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">typeEvaluator</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="getAllTrajectories"><a class="viewcode-back" href="../../../AdaptivePELE.clustering.html#AdaptivePELE.clustering.clustering.getAllTrajectories">[docs]</a><span class="k">def</span> <span class="nf">getAllTrajectories</span><span class="p">(</span><span class="n">paths</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find all the trajectory files in the paths specified</span>

<span class="sd">        :param paths: The path where to find the trajectories</span>
<span class="sd">        :type paths: str</span>
<span class="sd">        :returns: list -- A list with the names of all th trajectories in paths</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">files</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
        <span class="n">files</span> <span class="o">+=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="c1"># sort the files obtained by glob by name, so that the results will be the</span>
    <span class="c1"># same on all computers</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">files</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Daniel Lecina, Joan Francesc Gilabert.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>